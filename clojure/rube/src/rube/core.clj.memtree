(ns rube.core
  (:require clojure.contrib.math))

;; xxx for notes: eval order ... different from CL.
;;
;; xxx for notes:  this is FU'ed
;; (class '(2 3 4))
;; (class (cons 1 '(2 3 4)))
;;
;;----------------------------------------------------------------
;; OK IN CL:
;(defun foo (x)
;(+ 1 (bar x)))
;
;(defun bar (x) (* 2 x))
;(print (foo 10))
;;----------------------------------------------------------------
;; NOT OK IN CLJ:
;
;(defn foo [x]
; (+ 1 (bar x)))
;(defn bar [x] (* 2 x))
;
;(print (foo 10))
;
; BUT WORKS ON W/ BAR DEF'D BEFORE FOO
;;----------------------------------------------------------------
;;

;;;; ================================================================
;;;; RUBE.CLJ
;;;;
;;;; Constructs the cycle decomposition of sequences of moves on the Rubik's
;;;; Cube.  Faces are denoted by F, R, B, L, U and D for front, right, back,
;;;; left, up and down, respectively.  Corner pieces are denoted by their three
;;;; faces, or 'elements', edges by their two.
;;;;
;;;; Moves are denoted by their face and either: +, -, or 2, for clockwise,
;;;; counterclockwise and half-turn, or no suffix, -1 and 2, for CW, CCW and
;;;; half-turn.  Examples: U+, F-1, R2.
;;;;
;;;; Processes are given as a list of moves, e.g. '(U+ F-1 R2).  Note that the
;;;; two notation styles for turns may be intermixed; however, the first style
;;;; is higher in the association lists, resulting in faster lookup time.
;;;;
;;;; John Kerl
;;;; 12/93
;;;; Ported to Clojure Dec. 2012 ...
;;;; ================================================================
;;;; This software is released under the terms of the GNU GPL.
;;;; Please see LICENSE.txt in the same directory as this file.
;;;; ================================================================

;;; =============================================================================
;;; RUBE DATA SECTION -- lookup tables.

;; The names of three adjacent faces provides the name of a corner piece.
;; However, those three faces may be combined in any of six ways, e.g.
;; URF, UFR, FRU, FUR, RFU, and RUF.
;; This variable contains all such names in which the faces are listed
;; in a clockwise direction.  This could be calculated at run-time,
;; but it seems simpler to do a table lookup.
(def table-clockwise-orient-set
  #{'URF 'UFL 'ULB 'UBR 'DFR 'DRB 'DBL 'DLF
    'RFU 'FLU 'LBU 'BRU 'FRD 'RBD 'BLD 'LFD
    'FUR 'LUF 'BUL 'RUB 'RDF 'BDR 'LDB 'FDL})

;; Data for the image of a face under a move.  Faces are down the table; moves are across.
;; Faces are represented as characters; moves are represented by symbols.
;; Key into this table by face to get an array of images of that face.
;; Index into the resulting array, using the table-move-index-lookup-alist, to get
;; the image of the specified face under the specified move.
(def table-move-on-face-table
	  ;;     F+ R+ B+ L+ U+ D+ F- R- B- L- U- D- F2 R2 B2 L2 U2 D2
	  ;; FRBLUD going down
	  {\F [ \F \U \F \D \L \R \F \D \F \U \R \L \F \B \F \B \B \B ],
	   \R [ \D \R \U \R \F \B \U \R \D \R \B \F \L \R \L \R \L \L ],
	   \B [ \B \D \B \U \R \L \B \U \B \D \L \R \B \F \B \F \F \F ],
	   \L [ \U \L \D \L \B \F \D \L \U \L \F \B \R \L \R \L \R \R ],
	   \U [ \R \B \L \F \U \U \L \F \R \B \U \U \D \D \D \D \U \R ],
	   \D [ \L \F \R \B \D \D \R \B \L \F \D \D \U \U \U \U \D \D ]})

;; See above comment.
;; xxx maybe reduce table count by one, using a hash map.
(def table-move-index-lookup-alist
   {'F+    0, 'R+    1, 'B+     2, 'L+    3, 'U+    4, 'D+    5,
    'F-    6, 'R-    7, 'B-     8, 'L-    9, 'U-   10, 'D-   11,
    'F2   12, 'R2   13, 'B2    14, 'L2   15, 'U2   16, 'D2   17,
    'F     0, 'R     1, 'B      2, 'L     3, 'U     4, 'D     5,
    'F-1   6, 'R-1   7, 'B-1    8, 'L-1   9, 'U-1  10, 'D-1  11,
    'f+    0, 'r+    1, 'b+     2, 'l+    3, 'u+    4, 'd+    5,
    'f-    6, 'r-    7, 'b-     8, 'l-    9, 'u-   10, 'd-   11,
    'f2   12, 'r2   13, 'b2    14, 'l2   15, 'u2   16, 'd2   17,
    'f     0, 'r     1, 'b      2, 'l     3, 'u     4, 'd     5,
    'f-1   6, 'r-1   7, 'b-1    8, 'l-1   9, 'u-1  10, 'd-1  11})

;; A table (represented as a hash map) to show the inverse of any move.
(def table-invert-move-alist
	  {'F+  'F-, 'R+  'R-, 'B+  'B-, 'L+  'L-, 'U+  'U-, 'D+  'D-,
       'F-  'F+, 'R-  'R+, 'B-  'B+, 'L-  'L+, 'U-  'U+, 'D-  'D+,
       'F2  'F2, 'R2  'R2, 'B2  'B2, 'L2  'L2, 'U2  'U2, 'D2  'D2,
       'F   'F-, 'R   'R-, 'B   'B-, 'L   'L-, 'U   'U-, 'D   'D-,
       'f+  'f-, 'r+  'r-, 'b+  'b-, 'l+  'l-, 'u+  'u-, 'd+  'd-,
       'f-  'f+, 'r-  'r+, 'b-  'b+, 'l-  'l+, 'u-  'u+, 'd-  'd+,
       'f2  'f2, 'r2  'r2, 'b2  'b2, 'l2  'l2, 'u2  'u2, 'd2  'd2,
       'f   'f-, 'r   'r-, 'b   'b-, 'l   'l-, 'u   'u-, 'd   'd-})

;; A table of all the movable pieces (i.e., not including centers)
;; on the cube.
(def table-list-of-all-pieces
  '(UFR UFL UBL UBR DFR DFL DBL DBR
    UF UL UB UR FR FL BL BR DF DL DB DR))

;;; =============================================================================
;; RUBE PORTABILITY SECTION
;; Implementation of these functions depends on the platform:
;; xxx for clj, much more than this ...
;;
;; For Common Lisp, use "string".
;; For Emacs List, use "prin1-to-string".
(defn symbol-to-string [sym]
  (.toString sym))

;; For Common Lisp, use "char".
;; For Emacs List, use "aref".
(defn select-char-in-string [string elt]
  (.charAt string elt))

;; Common Lisp has symbolp, stringp, and characterp; Clojure has symbol? and
;; string?  but not character?.
(defn character? [p]
  (= (.getName (class p)) "java.lang.Character"))

;;; =============================================================================
;;; xxx note important for UT

;; The names of three adjacent faces provide the name of a corner piece;
;; the names of two adjacent faces provide the name of an edge piece.
;; However, a corner's three faces may be combined in any of six (3!) ways, e.g.
;; URF, UFR, FRU, FUR, RFU, and RUF; and an edge's two faces may be combined
;; in one of two (2!) ways, e.g. UF and FU.
;;
;; This function sees if two representations refer to the same piece.
;; E.g. UFR is the same as FRU; UFR is not the same as UFL; UFR is not the
;; same as UF.

(defn piece-equal [piece-1 piece-2]
  (let [length-1 (.length (symbol-to-string piece-1))
        length-2 (.length (symbol-to-string piece-2))]
    (cond (not (= length-1 length-2)) false ;; edges and corners can't possibly be the same

          (= length-1 3) ; Corner pieces; there are 6 face permutations to consider.
          (let [p1  (symbol-to-string piece-1)
                p2  (symbol-to-string piece-2)
                p11 (select-char-in-string p1 0)
                p12 (select-char-in-string p1 1)
                p13 (select-char-in-string p1 2)
                p21 (select-char-in-string p2 0)
                p22 (select-char-in-string p2 1)
                p23 (select-char-in-string p2 2)]
            (or
              (and (= p11 p21) (= p12 p22) (= p13 p23))
              (and (= p11 p21) (= p12 p23) (= p13 p22))
              (and (= p11 p22) (= p12 p21) (= p13 p23))
              (and (= p11 p22) (= p12 p23) (= p13 p21))
              (and (= p11 p23) (= p12 p21) (= p13 p22))
              (and (= p11 p23) (= p12 p22) (= p13 p21))))

          (= length-1 2) ; Edge pieces; there are 2 face permutations to consider.
          (let [p1  (symbol-to-string piece-1)
                p2  (symbol-to-string piece-2)
                p11 (select-char-in-string p1 0)
                p12 (select-char-in-string p1 1)
                p21 (select-char-in-string p2 0)
                p22 (select-char-in-string p2 1)]
            (or
              (and (= p11 p21) (= p12 p22))
              (and (= p12 p21) (= p11 p22))))

          ;; The 't' statement (:else in Clojure) kept this predicate from
          ;; returning #<unspecified> in Scheme.
          :else (= piece-1 piece-2))))

(defn piece-lists-equal [list-1 list-2]
  ;; Principally for unit-test
  (cond (and (empty? list-1) (empty? list-2))
        true
        (and (empty? list-1) (not (empty? list-2)))
        false
        (and (empty? list-2) (not (empty? list-1)))
        false
        (not (piece-equal (first list-1) (first list-2)))
        false
        :else
        (recur (rest list-1) (rest list-2))))

;;; =============================================================================
;;; RUBE LOWEST-LEVEL-MOVES SECTION
;;; Image of a single face under a move.

(defn is-corner-piece [piece]
  (= 3 (.length (symbol-to-string piece))))
(defn is-edge-piece [piece]
  (= 2 (.length (symbol-to-string piece))))

;; ----------------------------------------------------------------
;; Returns the image of a face under a move.
;; Faces are represented by characters; moves are represented by symbols.
;; Does a simple table lookup.
(defn move-on-face [move face]
  (let [row-vector (table-move-on-face-table face),
        vector-index (table-move-index-lookup-alist move)]
    (cond (= nil row-vector)
          (throw (format "move-on-face:  Rule lookup failed for face %s."
                         (cond (symbol? face) (symbol-to-string face)
                               (string? face) face
                               (character? face) (symbol-to-string face))))
          (= nil vector-index)
          (throw (format "move-on-face:  Rule lookup failed for move %s."
                         (cond (symbol? move) (.toString move)
                               (string? move) move
                               (character? move) (symbol-to-string move))))
          :else (nth row-vector vector-index))))

;;; =============================================================================
;;; RUBE NEXT-LOWEST-LEVEL-MOVES SECTION
;;; Image of one piece (having two or three faces, for edge or corner pieces,
;;; respectively) under a move.

;;----------------------------------------------------------------
;; Returns the image of a corner piece under a move.
;; Breaks the piece up into its component faces; looks up the image
;; of each face under the specifed move; then puts the resulting
;; faces back together.
;;
;; What the if-statement does is, if the move (denoted by a face)
;; isn't on the same face as one of the piece's faces, then the
;; piece is unaffected by the move.  E.g. URF is affected by F;
;; but URL is not.
;;
;; Both arguments are represented by symbols.

(defn move-on-corner-piece [move corner]
  (let [ps   (symbol-to-string corner),
        ps0  (select-char-in-string ps 0),
        ps1  (select-char-in-string ps 1),
        ps2  (select-char-in-string ps 2),
        face (select-char-in-string (symbol-to-string move) 0)]
    (if (or (= face ps0) (= face ps1) (= face ps2))
      (symbol
        (str (symbol-to-string (move-on-face move ps0))
             (symbol-to-string (move-on-face move ps1))
             (symbol-to-string (move-on-face move ps2))))
      ;; else
      corner)))

;;----------------------------------------------------------------
;; Returns the image of an edge piece under a move.
;; Breaks the piece up into its component faces; looks up the image
;; of each face under the specifed move; then puts the resulting
;; faces back together by turning a string into a symbol.
;; (See Steele's CLTL for a description of the difference between
;; intern and make-symbol.  For me, the relevant difference is that
;; a symbol created with make-symbol prints with a leading #: (ugly),
;; whereas a symbol created with intern doesn't (pretty).)
;;
;; What the if-statement does is, if the move (denoted by a face)
;; isn't on the same face as one of the piece's faces, then the
;; piece is unaffected by the move.  E.g. UF is affected by F;
;; but UR is not.
;;
;; Both arguments are represented by symbols.

(defn move-on-edge-piece [move edge]
  (let [ps   (symbol-to-string edge)
        ps0  (select-char-in-string ps 0)
        ps1  (select-char-in-string ps 1)
        face (select-char-in-string (symbol-to-string move) 0)]
    (if (or (= face ps0) (= face ps1))
      (symbol
        (str
          (symbol-to-string (move-on-face move ps0))
          (symbol-to-string (move-on-face move ps1))))
      ;; else
      edge)))

;;; =============================================================================
;;; RUBE THIRD-LOWEST-LEVEL-MOVES SECTION
;;; Image of a sequence of moves on a single (edge or corner) piece.

;; -----------------------------------------------------------------------------
(defn moves-on-piece [moves piece]
  ;; Need to tune this (use an auxiliary function? moves-on-corner-piece and
  ;; moves-on-edge-piece?) so that it doesn't check the same piece over and
  ;; over for corner/edge.  Once passed in, it won't change!
  (if (is-corner-piece piece)
    (if (empty? moves)
      piece
      (recur
        (rest moves)
        (move-on-corner-piece (first moves) piece)))
    (if (empty? moves)
      piece
      (recur
        (rest moves)
        (move-on-edge-piece (first moves) piece)))))

;;; =============================================================================
;;; RUBE FOURTH-LOWEST-LEVEL-MOVES SECTION
;;; Image of a sequence of moves on a list of pieces.

;;----------------------------------------------------------------
(defn moves-on-pieces [moves pieces]
  (map (fn [piece] (moves-on-piece moves piece)) pieces))

;;; =============================================================================
;;; RUBE EXPONENT SECTION

(defn invert-move [move]
  (let [inv (table-invert-move-alist move)]
    (cond (nil? inv)
          (throw
            (format
              "invert-move:  Couldn't find inverse for %s\n" (.tostring move)))
          :else
          inv)))

(defn invert-moves [moves]
  ;; Inverting a list of moves means reversing it and replacing each
  ;; individual move with its inverse: (A * B)^-1 = B^-1 * A^-1.
  (cond (empty? moves) '()
        (not (list? moves)) (list moves)
        :else
        (concat
          (invert-moves (rest moves))
          (list (invert-move (first moves))))))

(defn power-of-sequence [moves power]
  ;; Negative exponents indicate inversion.
  (cond (= power  0) '()
		(= power  1) moves
		(> power  1) (concat moves (power-of-sequence moves (- power 1)))
		(= power -1) (invert-moves moves)
		(< power -1) (power-of-sequence (invert-moves moves) (- power))))

(defn conjugate [moves1 moves2]
  ;; The conjugate of A by B: denoted A * B * A^-1.
  (let [lmoves1 (if (symbol? moves1) (list moves1) moves1)
        lmoves2 (if (symbol? moves2) (list moves2) moves2)]
    (concat lmoves1 lmoves2 (invert-moves lmoves1))))

(defn commutator [moves1 moves2]
  ;; The commutator of two moves or list of moves on the Rubik's Cube.  In
  ;; group theory, the commutator of A and B, written [A B], is defined to be A
  ;; * B * A^-1 * B^-1.  Then [A B] == the identity sequence precisely when A
  ;; and B commute (i.e. when A*B == B*A).
  ;;
  ;; Note however that at this we have [U D] = (U D U- D-) which clearly is the
  ;; identity on the cube but which is not pared down to such symbolically.
  ;; This fact will be discovered by cycle decomposition.
  (let [lmoves1 (if (symbol? moves1) (list moves1) moves1)
		lmoves2 (if (symbol? moves2) (list moves2) moves2)]
    (concat lmoves1 lmoves2
            (invert-moves lmoves1) (invert-moves lmoves2))))

;;; =============================================================================
;;; RUBE CYCLE SECTION

(defn cycle-length [cycle]
  ;; Supports the signed-cycle notation used by the cycle-decomposition logic.
  ;; E.g. the cycle '(UFR DFL) has length 2.  But '(UFR +) has length, not 1,
  ;; but 3.  Likewise '(UF UB +) has length 4.
  (if (or (= (last cycle) '+) (= (last cycle) '-))
    (let [num-faces (.length (symbol-to-string (first cycle)))]
      (cond (= num-faces 3)
            (* 3 (- (count cycle) 1))
            (= num-faces 2)
            (* 2 (- (count cycle) 1))
            :else (count cycle)))
    (count cycle)))

;; -----------------------------------------------------------------------------
;; xxx maybe delete?  only used by the cycle-finder?
(defn memtree? [atm tree]
  ;; A predicate to determine whether non-null atom ATM is rube-equivalent to
  ;; an atomic member of TREE (i.e. if the piece given by atm is the same piece
  ;; as one in the tree, not considering spin).
  (cond (and (list? tree) (empty? tree)) false
        (not (list? tree)) (piece-equal atm tree)
		;; ((equal atm tree) t) ;; I would use equal outside of Rube code.
        ;; I want to see if a piece has already been decomposed, regardless of
        ;; orientation; hence the need for piece-equal.
		:else (or (memtree? atm (first tree)) (memtree? atm (rest tree)))))

;; -----------------------------------------------------------------------------
(defn sign-of-rotation [orient-1 orient-2]
  ;; xxx comment re context
  (cond
    ; Same representation of same piece -- no spin.
    (= orient-1 orient-2) '()

    ; No sign if the pieces aren't the same.
    (not (piece-equal orient-1 orient-2)) '()

    ; Arbitrarily, say + for any differently represented edges
	; (the rotation group only has order 2).
    (is-edge-piece orient-1) '(+)

    ; Now they must be corner pieces.  Do a table lookup.
    (contains? table-clockwise-orient-set orient-1)
    (if (= (select-char-in-string (symbol-to-string orient-1) 1)
           (select-char-in-string (symbol-to-string orient-2) 0))
      '(+) '(-))
    :else
    (if (= (select-char-in-string (symbol-to-string orient-1) 1)
           (select-char-in-string (symbol-to-string orient-2) 0))
      '(-) '(+))))

;; -----------------------------------------------------------------------------
;; xxx comment

(defn find-cycle-aux [piece-list start-piece moves]
  ;; Returns the unsigned cycle of piece under moves, reversed.
  ;; This is an implementation detail of the cycle-finder.
  (let [curr-piece (first piece-list)
        next-piece (moves-on-piece moves curr-piece)]
    (if (piece-equal next-piece start-piece)
      piece-list
      (recur (cons next-piece piece-list) start-piece moves))))

(defn find-cycle [piece moves]
  (let [unsigned-reversed-cycle (find-cycle-aux (list piece) piece moves)
        next-piece (moves-on-piece moves (first unsigned-reversed-cycle))]
    (reverse (concat (sign-of-rotation next-piece piece) unsigned-reversed-cycle))))

;;;----------------------------------------------------------------
(defn find-cycles-aux [pieces moves current-cycles]
  (cond (empty? pieces)
        current-cycles

        (memtree? (first pieces) current-cycles)
        (recur (rest pieces) moves current-cycles)

        :else
        (let [new-cycle (find-cycle (first pieces) moves)
              augmented-cycles (concat (list new-cycle) current-cycles)]
        (recur (rest pieces) moves augmented-cycles))))

(def pieces '(UFR UFL))
(def moves '(U))
(def current-cycles '())

(def x (cons '(1 2 3) '()))
(class x)

(def new-cycle '(1 2 3))
(def current-cycles '())
(class (cons '(1 2 3) '()))
(class (cons '(1 2 3) '((4 5 6))))
(concat '(1 2 3) '())
(list? (concat (list '(1 2 3)) '((4 5 6))))
(class '(1 2 3))

(class (cons '() '(1 2 3)))
(class (cons 4 '(1 2 3)))
(class '(1 2 3))
(class (cons '(1 2 3) '((4 5 6))))

(class (concat '(1 2 3) '()))
(class (concat '(1 2 3) '()))
(list (concat '((1 2 3)) '()))



(empty? pieces)
(memtree? (first pieces) current-cycles)
(def new-cycle (find-cycle (first pieces) moves))
(def augmented-cycles (cons new-cycle current-cycles))

(def pieces '(UFL))
(def current-cycles augmented-cycles)
pieces
(first pieces)
current-cycles
(memtree? (first pieces) current-cycles)
(list augmented-cycles)

(memtree? 'UFL '((UFR ULF UBL URB)))
(memtree? (first '(UFL)) '((UFR ULF UBL URB)))
(memtree? (first pieces) '((UFR ULF UBL URB)))
(memtree? (first pieces) current-cycles)

(memtree? 'UFL '((UFR ULF UBL URB)))
(memtree? 'UFL current-cycles)
(class '((UFR ULF UBL URB)))
(class current-cycles)

current-cycles
(= current-cycles '((UFR ULF UBL URB)))

(first pieces)
augmented-cycles

(defn find-cycles [pieces moves]
  (find-cycles-aux pieces moves '()))

(find-cycles '(UFR) '(U))
(find-cycles '(UF) '(U))
(find-cycles '(UFR UFL) '(U))
(find-cycles '(UFR UF) '(U))
;(find-cycles table-list-of-all-pieces '(U))
;
;(delete-one-cycles (find-cycles table-list-of-all-pieces '(U))))

;; -----------------------------------------------------------------------------
(defn delete-one-cycles [cycles]
  (filter
    (fn [cycle] (> (count cycle) 1))
    cycles))

;; -----------------------------------------------------------------------------
(defn cycle-decomposition [moves]
  ;; Given a list of Rubik's Cube pieces and a list of moves, return the cycle
  ;; decomposition of the moves, omitting trivial cycles.
  (delete-one-cycles (find-cycles table-list-of-all-pieces moves)))

;(cycle-decomposition '(F))
;(cycle-decomposition '(F R))
;(cycle-decomposition '(F R B L))
;(cycle-decomposition '(F2 R2))
;(cycle-decomposition '(F2))
;(cycle-decomposition '(F2 B2))

;;; =============================================================================
;;; =============================================================================
;;; TO FILE
;;; =============================================================================
;;; =============================================================================

;; CD:
;; (defn cycle-decomposition [moves])
;; (defn delete-one-cycles [cycles])
;; (defn find-cycle [piece moves])
;; (defn memtree? [atm tree])
;; (defn piece-equal [piece-1 piece-2])
;; (defn sign-of-rotation [orient-1 orient-2])

;; ORDER:
;; (defn order [cycle-list])
;; (defn order [moves])

;; PPRINT:
;; (defn rube-pprint [lst])

;; TELL-ABOUT:
;; (defn pared-moves-on-all-pieces [moves])

;; -----------------------------------------------------------------------------
;;	(defn pprint-cycle-decomposition [moves]
;;	  (rube-pprint (cycle-decomposition moves)))

;; -----------------------------------------------------------------------------
;;	(defn pared-moves-on-all-pieces [moves]
;;	  (labels ((diff (image original)
;;			 (cond ((or (nil? image) (nil? original)) '())
;;			       ((equal (first image) (first original))
;;				(diff (rest image) (rest original)))
;;			       (t
;;				(cons
;;				 (if (piece-equal (first image) (first original))
;;				     (cons (first original) (sign-of-rotation
;;							   (first original) (first image)))
;;				   (list (first original) '-> (first image)))
;;				 (diff (rest image) (rest original)))))))
;;	    (diff (moves-on-pieces moves table-list-of-all-pieces)
;;		  table-list-of-all-pieces)))
;;	;; (pared-moves-on-all-pieces '(F))
;;	;; (setf moves '(F))

	;; (piece-equal 'UFR 'URF)
	;; (piece-equal 'UFR 'URL)
	;; (piece-equal 'UFR 'UF)

;;;; -----------------------------------------------------------------------------
;;;; RUBE EXPONENT SECTION

;;	;; (defn order [cycle-list]
;;	;; 		(apply #'lcm (map cycle-length cycle-list)))
;; xxx this isn't right.  need cycle-decomposition; e.g. [U D U- D].
;;(defn order [moves]
;;  (clojure.contrib.math/lcm (mapcar #'cycle-length (cycle-decomposition moves))))

;;;; -----------------------------------------------------------------------------
;;;; RUBE PPRINT SECTION

;; This is a function to print output of cycle-decomposition with nice line breaks.
;; Actually what is does is print the elements of any list one line at a time.
;(defn rube-pprint [lst]
;	  (labels
;	      ((rube-pprint-aux (lst)
;				(cond
;				 ((nil? lst) nil)
;				 ((not (consp lst)) (format t "~A~%" lst))
;				 (t
;				  (progn
;				    (format t "~A~%" (first lst))
;				    (rube-pprint-aux (rest lst)))))))
;	    (rube-pprint-aux lst))
;	  (values))

;;	;; (rube-pprint '(a b c d e))
;;	;; (rube-pprint '((a b) (c d) (e f)))

;;;; -----------------------------------------------------------------------------
;;;; TESTS

;;	;; (mapcar #'(lambda (x)	  (move-on-face 'U x)) '(\F \R \B \L \U \D))
;;
;;	;; (setf forward-moves  '(F R B L U D))
;;	;; (setf backward-moves '(F- R- B- L- U- D-))
;;	;; (setf double-moves   '(F2 R2 B2 L2 U2 D2))
;;
;;	;; (mapcar #'(lambda (x) (move-on-edge-piece x 'UF)) forward-moves)
;;	;; (mapcar #'(lambda (x) (move-on-edge-piece x 'UF)) backward-moves)
;;	;; (mapcar #'(lambda (x) (move-on-edge-piece x 'UF)) double-moves)
;;
;;	;; (mapcar #'(lambda (x) (move-on-edge-piece x 'FU)) forward-moves)
;;	;; (mapcar #'(lambda (x) (move-on-edge-piece x 'FU)) backward-moves)
;;	;; (mapcar #'(lambda (x) (move-on-edge-piece x 'FU)) double-moves)
;;
;;	;; (mapcar #'(lambda (x) (move-on-corner-piece x 'UFR)) forward-moves)
;;	;; (mapcar #'(lambda (x) (move-on-corner-piece x 'UFR)) backward-moves)
;;	;; (mapcar #'(lambda (x) (move-on-corner-piece x 'UFR)) double-moves)
;;
;;	;; (piece-equal 'UFR 'FRU)
;;	;; (piece-equal 'Ufr 'FUR)
;;	;; (piece-equal 'FUR 'FUR)
;;	;; (piece-equal 'FUR 'FU)
;;	;;
;;	;; (sign-of-rotation 'UFR 'FRU)
;;	;; (sign-of-rotation 'UFR 'UFR)
;;	;; (sign-of-rotation 'UFR 'URF)
;;	;; (sign-of-rotation 'UFR 'FR)
;;	;; (sign-of-rotation 'RF 'FR)
;;	;; (sign-of-rotation 'RF 'RF)
;;	;;
;;	;; (memtree? 'UF '(FR UR BL DL))
;;	;; (memtree? 'U '(F R B U))
;;	;; (piece-equal 'U 'F)
;;	;; (moves-on-piece '(F) (moves-on-piece '(F) (moves-on-piece '(F)(moves-on-piece '(F) 'UFR))))
;;	;;
;;	;; (find-cycle 'UFR '(F))
;;	;; (find-cycle 'UF '(U2))
;;	;; (find-cycle 'UFR '(F))
;;	;; (find-cycle 'UFR '(F R B L))
;;	;; (find-cycle 'UF '(B))
;;	;; (find-cycle 'UF '(F R))
;;	;; (find-cycle 'UF (power-of-sequence '(F2 R2) 2))
;;	;; (find-cycle 'UF (power-of-sequence '(F2 R2) 3))
;;	;; (find-cycle 'UFR '(F R))
;;	;; (find-cycle 'UFR '(F R B L))
;;	;;
;;	;; (invert-moves '(F+ R+ B+ L+))
;;	;; (conjugate '(F R) '(B L))
;;	;; (commutator '(F R) '(B L))
;;	;; (conjugate '(B) (power-of-sequence '(L U L- U-) 3))
;;	;;
;;	;; (cycle-decomposition '(F R B L))
;;	;; (cycle-decomposition (power-of-sequence '(F R) 2))
;;	;; (cycle-decomposition '(B- U2 B2 U B- U- B- U2 F R B R- F-))
;;	;; (cycle-decomposition '(R L- F R- L D2 R L- F R- L))
;;	;; (cycle-decomposition (power-of-sequence '(B R- D2 R B- U2) 1))
;;	;; (cycle-decomposition (power-of-sequence '(B R- D2 R B- U2) 2))
;;	;; (cycle-decomposition (power-of-sequence '(F R) 2))
;;	;; (cycle-decomposition (power-of-sequence '(F2 R2) 6))
;;	;; (cycle-decomposition
;;	;;   '(R L- F  R- L D
;;	;;  	 R L- F  R- L D
;;	;;  	 R L- F2 R- L D
;;	;;  	 R L- F  R- L D
;;	;;  	 R L- F  R- L D2))
;;	;; (moves-on-pieces (power-of-sequence '(B R- D2 R B- U2) 2) table-list-of-all-pieces)
;;	;; (moves-on-pieces '(R L- F R- L D2 R L- F R- L) '(DR DB DL))
;;	;; (moves-on-pieces '(R L- F R- L D2 R L- F R- L) table-list-of-all-pieces)
;;	;; (moves-on-pieces (power-of-sequence '(B R- D2 R B- U2) 2) table-list-of-all-pieces)
;;	;; (pared-moves-on-all-pieces '(R L- F R- L D2 R L- F R- L))
;;	;; (pared-moves-on-all-pieces (power-of-sequence '(B R- D2 R B- U2) 2))
;;	;; (pared-moves-on-all-pieces (power-of-sequence '(F2 R2) 2))
;;	;;
;;	;; (order (power-of-sequence '(B R- D2 R B- U2) 2))
;;	;; (order '(R L- F R- L D2 R L- F R- L))
;;	;; (order '(R L- F R- L D2 R L- F R- L))
;;	;; (order (power-of-sequence '(B R- D2 R B- U2) 2))
;;	;; (order '(R L- F R- L D2 R L- F R- L))
;;	;; (order (power-of-sequence '(B R- D2 R B- U2) 2))
;;	;; (order (power-of-sequence '(F2 R2) 2))
;;	;; (order '(F R B L))
;;	;; (order '(F2 R2))
;;	;; (order '(F R))
;;	;; (order '(F R-))
;;	;; (order '(F R2))
;;	;; (order '(F U R))
;;	;; (order '(F U R B D L))
;;	;; (order '(F U R B L D))
;;	;; (order '(F))
;;	;;
;;
;;	;; (setf moves '(F2 R2))
;;
;;	(defn tell-about [moves]
;;	  (format t "-- Sequence is: ~%~A~%~%" moves)
;;	  (format t "-- Image is: ~%~A~%~%" (pared-moves-on-all-pieces moves))
;;	  (format t "-- Cycle decomposition is: ~%~A~%~%" (cycle-decomposition moves))
;;	  (format t "-- Order is: ~%~A~%~%" (order moves))
;;	  (values))
;;
;;	(defn tell-about [moves]
;;	  (format t "~%-- Sequence is: ~%~A~%" moves)
;;	  (format t "~%-- Image is: ~%")
;;	  (rube-pprint (pared-moves-on-all-pieces moves))
;;	  (format t "~%-- Cycle decomposition is: ~%")
;;	  (rube-pprint (cycle-decomposition moves))
;;	  (format t "~%-- Order is: ~%~A~%~%" (order moves))
;;	  (values))
;;
;;	;; (values) to avoid having a return value from this defn print out.
;;
;;	;; rube-pprint prints each element of a list on a line by itself;
;;	;; format with a ~A prints all the elements of a list on one line.
;;	;;
;;	;; So I could use these in tell-about -- having each list element on a
;;	;; single line makes output more readable, but on the other hand makes
;;	;; the window scroll a lot.  Kind of a trade-off.  For now, I'm not
;;	;; using these.
;;
;;	;;	 (rube-pprint (pared-moves-on-all-pieces moves))
;;	;;	 (rube-pprint (cycle-decomposition moves))
;;
;;
;;	;; (tell-about '(F))
;;	;; (tell-about (power-of-sequence '(B R- D2 R B- U2) 2))
;;	;; (tell-about '(R L- F R- L D2 R L- F R- L))
;;	;; (tell-about (power-of-sequence '(F2 R2) 2))
;;	;; (tell-about '(F R B L))
;;	;; (tell-about '(F R B L D U))
;;	;; (tell-about '(R L- F  R- L D
;;	;; 	 R L- F  R- L D
;;	;; 	 R L- F2 R- L D
;;	;; 	 R L- F  R- L D
;;	;; 	 R L- F  R- L D2))
;;	;;
